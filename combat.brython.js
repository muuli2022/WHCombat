__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1644520870656, "combat": [".py", "from browser import document,bind\nfrom browser.html import P,BR,B\nfrom dataclasses import dataclass\n\nimport random\nimport combatfunctions as cf\n\n@dataclass\nclass Opponent:\n name:str=\"dummy\"\n WS:int=80\n S:int=4\n T:int=3\n W:int=7\n I:int=40\n A:int=2\n parry:bool=False\n sudden_death:bool=False\n \n def throwDamage(self):\n  a=random.randint(1,6)\n  \n  if a ==6:\n   return self.extraDamage()\n  else :\n   return a+self.S\n   \n def extraDamage(self):\n  damage=6\n  \n  if random.randint(1,100)<self.WS:\n  \n   docOutput(\"Extra damage!\",\"bold\")\n   roll=random.randint(1,6)\n   while roll ==6:\n    docOutput(\"More extra damage\",\"bold\")\n    damage +=6\n    roll=random.randint(1,6)\n    \n   damage +=roll\n   \n  return damage+self.S\n  \n@bind(document[\"set_Bertold\"],\"click\")\ndef setBertold(ev):\n\n document['n_d'].value=\"Bertold\"\n document['ws_d'].value=\"69\"\n document['s_d'].value=\"7\"\n document['t_d'].value=\"12\"\n document['w_d'].value=\"13\"\n document['i_d'].value=\"63\"\n document['a_d'].value=\"4\"\n \n setAttributesOf(defender,\"d\")\n \n docOutput(\"Bertold set\")\n \n@bind(document[\"set_Michael\"],\"click\")\ndef setMichael(ev):\n\n document['n_d'].value=\"Michael\"\n document['ws_d'].value=\"79\"\n document['s_d'].value=\"10\"\n document['t_d'].value=\"10\"\n document['w_d'].value=\"14\"\n document['i_d'].value=\"58\"\n document['a_d'].value=\"4\"\n \n setAttributesOf(defender,\"d\")\n \n docOutput(\"Michael set\")\n \n \n \n \n \n \n \n \n \n@bind(document[\"round\"],\"click\")\ndef round(ev):\n\n setAttributesOf(defender,\"d\")\n \n \n defender_initiatives=cf.calculateInitiatives(defender.I,defender.A)\n \n hitlist=getHitlist(attackers)\n \n hitlist=cf.createHitList(hitlist,defender_initiatives,\"d\")\n \n hitlist.sort(reverse=True )\n \n \n defenders=[\"d\"]\n combatants=attackers+defenders\n \n \n hitlist=updateRoundStatusToHitlist(hitlist,combatants)\n \n document[\"output\"]<=P(B(runCombatRound(hitlist)))\n \n document[\"output\"].scrollTop=document[\"output\"].scrollHeight\n \n@bind(document[\"sudden_death\"],\"click\")\ndef suddenDeath(ev):\n attacker.sudden_death=document[\"sudden_death\"].checked\n \n \n@bind(document[\"parry_d\"],\"click\")\ndef defenderParry(ev):\n defender.parry=document[\"parry_d\"].checked\n \ndef addAttackerInOutHandler(i):\n @bind(document[f\"inout_a{i}\"],\"click\")\n def attackerInOut(ev):\n \n  if attackers.count(f\"a{i}\")==0:\n   attackers.append(f\"a{i}\")\n  else :\n   attackers.remove(f\"a{i}\")\n   \n   \nfor i in range(1,5):\n addAttackerInOutHandler(i)\n \ndef docOutput(string,styling=None ):\n\n if styling ==\"bold\":\n  document[\"output\"]<=B(string)\n  document[\"output\"]<=BR()\n else :\n  document[\"output\"]<=(string)\n  document[\"output\"]<=BR()\n  \n  \ndef setAttributesOf(opponent,suffix):\n opponent.name=document['n_'+suffix].value\n opponent.WS=int(document['ws_'+suffix].value)\n opponent.S=int(document['s_'+suffix].value)\n opponent.T=int(document['t_'+suffix].value)\n opponent.W=int(document['w_'+suffix].value)\n opponent.I=int(document['i_'+suffix].value)\n opponent.A=int(document['a_'+suffix].value)\n \n if suffix !=\"d\":\n  opponent.parry=document['parry_'+suffix].checked\n  \n  \ndef getHitlist(attackers):\n\n hitlist=[]\n i=0\n while i <len(attackers):\n \n  temp_initiative=cf.calculateInitiatives(int(document['i_'+attackers[i]].value),int(document['a_'+attackers[i]].value))\n  hitlist=cf.createHitList(hitlist,temp_initiative,attackers[i])\n  i +=1\n  \n hitlist.sort(reverse=True )\n \n return hitlist\n \n \ndef saveRoundStatus(hitlist,attackers,isend):\n\n defenders=[\"d\"]\n \n combatants=attackers+defenders\n \n if isend ==0:\n  i=0\n  \n  while i <len(combatants):\n   k=0\n   temp=0\n   while k <len(hitlist):\n    if hitlist[k][1]==combatants[i]:\n     temp=temp+hitlist[k][2]\n    k +=1\n   document['ua_'+combatants[i]].value=str(temp)\n   i +=1\n else :\n \n  i=1\n  \n  while i <5:\n   document['ua_'+'a'+str(i)].value=\"0\"\n   \n   i +=1\n   \n  document['ua_d'].value=\"0\"\n  \n return\n \ndef updateRoundStatusToHitlist(hitlist,combatants):\n\n i=0\n \n while i <len(combatants):\n \n  k=0\n  j=0\n  while k <len(hitlist):\n  \n   if hitlist[k][1]==combatants[i]:\n    if j ==int(document['ua_'+combatants[i]].value):\n     break\n    hitlist[k][2]=1\n    j +=1\n    \n   k +=1\n   \n  i +=1\n  \n return hitlist\n \ndef runCombatRound(hitlist):\n i=0\n attacks=len(hitlist)\n \n message=\"\"\n \n while i <attacks:\n \n  if hitlist[i][3]==\"a\":\n   setAttributesOf(attacker,hitlist[i][1])\n   if hitlist[i][2]==0:\n    message=attacker.name+\" hits on initiative \"+str(hitlist[i][0])\n    docOutput(message)\n    \n    hitlist=cf.markAttackUsed(hitlist,hitlist[i][1],i,0)\n    \n    hit=random.randint(1,100)\n    \n    message=attacker.name+\" threw \"+str(hit)\n    docOutput(message)\n    \n    if hit <=attacker.WS:\n    \n     message=attacker.name+\" hits \"+str(cf.findHitLocation(hit))\n     docOutput(message)\n     \n     damage=attacker.throwDamage()\n     \n     parry_outcome=0\n     \n     if defender.parry:\n      parry_outcome=cf.parryResult(hitlist,\"d\",i,defender.WS)\n      \n      hitlist=cf.markAttackUsed(hitlist,\"d\",i,0)\n      \n      if parry_outcome >0:\n       message=defender.name+\" parried \"+str(parry_outcome)+\" points of damage.\"\n       docOutput(message)\n      else :\n       message=defender.name+\"'s parry was unsuccesful.\"\n       docOutput(message)\n       \n     outcome=cf.findHitOutcome(damage,defender.T,parry_outcome)\n     \n     message=attacker.name+\" did \"+str(damage)+\" points damage and \"+defender.name+\" lost \"+str(outcome)+\" wounds\"\n     docOutput(message)\n     defender.W -=outcome\n     \n     document['w_d'].value=str(defender.W)\n     \n     if defender.W <0:\n      temp=str(defender.W)\n      \n      criticalHit=\"+\"+temp[1:]\n      defender.W=0\n      document['w_d'].value=str(defender.W)\n      \n      message=defender.name+\" suffers \"+criticalHit+\" critical hit. Throw a critical effect!\"\n      saveRoundStatus(hitlist,attackers,0)\n      return message\n     else :\n      message=defender.name+\" has \"+str(defender.W)+\" wounds left.\"\n      docOutput(message)\n      \n    else :\n    \n     if cf.checkFumble(hit)==\"Miss!\":\n      docOutput(\"Miss!\")\n     else :\n      message=attacker.name+\" fumbled with roll \"+str(hit)+\". Loose one attack.\"\n      docOutput(message,\"bold\")\n      hitlist=cf.markAttackUsed(hitlist,hitlist[i][1],i,1)\n      \n   else :\n    message=attacker.name+\" has already used action on initiative \"+str(hitlist[i][0])\n    docOutput(message)\n    \n   i +=1\n  else :\n   setAttributesOf(defender,\"d\")\n   if hitlist[i][2]==0:\n    message=defender.name+\" hits on initiative \"+str(hitlist[i][0])\n    docOutput(message)\n    \n    hitlist=cf.markAttackUsed(hitlist,\"d\",i,0)\n    \n    setAttributesOf(attacker,attackers[0])\n    \n    hit=random.randint(1,100)\n    \n    message=defender.name+\" threw \"+str(hit)\n    docOutput(message)\n    \n    if hit <=defender.WS:\n     message=defender.name+\" hits \"+str(cf.findHitLocation(hit))\n     docOutput(message)\n     \n     damage=defender.throwDamage()\n     \n     parry_outcome=0\n     \n     if attacker.parry:\n     \n      parry_outcome=cf.parryResult(hitlist,attackers[0],i,attacker.WS)\n      \n      hitlist=cf.markAttackUsed(hitlist,attackers[0],i,0)\n      \n      if parry_outcome >0:\n       message=attacker.name+\" parried \"+str(parry_outcome)+\" points of damage.\"\n       docOutput(message)\n      else :\n       message=attacker.name+\"'s parry was unsuccesful.\"\n       docOutput(message)\n       \n     outcome=cf.findHitOutcome(damage,attacker.T,parry_outcome)\n     \n     message=defender.name+\" did \"+str(damage)+\" points damage and \"+attacker.name+\" lost \"+str(outcome)+\" wounds\"\n     docOutput(message)\n     \n     attacker.W -=outcome\n     \n     document['w_'+attackers[0]].value=str(attacker.W)\n     \n     if attacker.W <0:\n     \n      temp=str(attacker.W)\n      \n      criticalHit=\"+\"+temp[1:]\n      attacker.W=0\n      document['w_'+attackers[0]].value=str(attacker.W)\n      \n      if attacker.sudden_death:\n      \n       critical_outcome=cf.checkSuddenDeath(int(temp[1:]),hit)\n       \n       if critical_outcome[0]==1:\n       \n        message=defender.name+\"'s\"+critical_outcome[1]\n        saveRoundStatus(hitlist,attackers,0)\n        \n        document['inout_'+attackers[0]].checked=False\n        \n        attackers.remove(attackers[0])\n        return message\n       else :\n        message=critical_outcome[1]\n        docOutput(message,\"bold\")\n      else :\n      \n       message=attacker.name+\" suffers \"+criticalHit+\" critical hit. Throw a critical effect!\"\n       saveRoundStatus(hitlist,attackers,0)\n       \n       return message\n       \n     else :\n      message=attacker.name+\" has \"+str(attacker.W)+\" wounds left.\"\n      docOutput(message)\n      \n    else :\n    \n     if cf.checkFumble(hit)==\"Miss!\":\n      docOutput(\"Miss!\")\n     else :\n      message=defender.name+\" fumbled with roll \"+str(hit)+\". Loose one attack.\"\n      docOutput(message,\"bold\")\n      hitlist=cf.markAttackUsed(hitlist,hitlist[i][1],i,1)\n      \n   else :\n    message=defender.name+\" has already used action on initiative \"+str(hitlist[i][0])\n    docOutput(message)\n    \n   i +=1\n   \n   \n saveRoundStatus(hitlist,attackers,1)\n \n return \"Attacks done!\"\n \n \n \n \n \ndefender=Opponent()\n\nattacker=Opponent()\n\nattackers=[]\n\n\n\n\n\n", ["browser", "browser.html", "combatfunctions", "dataclasses", "random"]], "combatfunctions": [".py", "\n\nimport random\n\ndef calculateInitiatives(init:int,a:int):\n\n initiatives=[]\n i=0\n while i <a:\n  initiatives.append(int(init /a *(a -i)))\n  i +=1\n  \n return initiatives\n \ndef throwHit(ws:int):\n\n a=random.randint(1,100)\n \n result=[]\n \n if ws >=a:\n  result=[\"Hit!\",str(a)]\n  return result\n else :\n  result=[checkFumble(a),str(a)]\n  return result\n  \ndef findHitLocation(hit:int):\n\n hitlocations=[15,35,55,80,90,100]\n hitlocationnames=[\"Head\",\"Right Arm\",\"Left Arm\",\"Body\",\"Left Leg\",\"Right Leg\"]\n \n temp=str(hit)\n \n if len(temp)==2:\n  hitlocation=int(temp[1]+temp[0])\n else :\n  hitlocation=int(temp+\"0\")\n  \n i=0\n \n while True :\n \n  if hitlocation <=hitlocations[i]:\n   return hitlocationnames[i]\n  else :\n   i +=1\n   \ndef findHitOutcome(damage,defence,parry):\n if damage >defence+parry:\n  return damage -defence -parry\n else :\n  return 0\n  \ndef checkFumble(hit:int):\n\n temp=str(hit)\n \n if len(temp)==1:\n  return \"Miss!\"\n  \n if hit ==100:\n  return \"Fumble!\"\n  \n if temp[0]==temp[1]:\n  return \"Fumble!\"\n  \n return \"Miss!\"\n \ndef parryResult(hitlist,defender,start,ws):\n\n parry_dmg=0\n \n i=start+1\n \n while i <len(hitlist):\n  if hitlist[i][1]==defender:\n   if hitlist[i][2]==0:\n   \n    proll=random.randint(1,100)\n    \n    if ws >=proll:\n     parry_dmg=random.randint(1,6)\n    else :\n     parry_dmg=0\n     \n    return parry_dmg\n    \n  i +=1\n  \n  \n return parry_dmg\n \ndef createHitList(hitlist_current,initiative_list,name):\n\n i=0\n \n while i <len(initiative_list):\n \n  hitlist_current.append([initiative_list[i],name,0,name[0]])\n  \n  i +=1\n  \n return hitlist_current\n \ndef markAttackUsed(hitlist,attacker,start,adjustment):\n i=start+adjustment\n while i <len(hitlist):\n  if hitlist[i][1]==attacker:\n   hitlist[i][2]=1\n   return hitlist\n  i +=1\n return hitlist\n \ndef checkSuddenDeath(critical_hit,hit):\n\n critical_ranges=[9,20,30,40,50,100]\n critical_outcomes=[[0,0,0,0,0,1],[0,0,0,0,1,1],[0,0,0,1,1,1],[0,0,1,1,1,1],[0,1,1,1,1,1],[1,1,1,1,1,1,1]]\n \n critical_roll=random.randint(1,100)\n \n if critical_hit >6:\n  critical_hit=6\n  \n i=0\n \n while True :\n \n  if critical_roll <=critical_ranges[i]:\n   critical_outcome=critical_outcomes[i][critical_hit -1]\n   break\n  else :\n   i +=1\n   \n if critical_outcome ==1:\n  hit_location=findHitLocation(hit)\n  message=\" blow smashes opponents \"+hit_location+\". Death from shock and blood loss is almost instantaneous.\"\n  return [critical_outcome,message]\n else :\n  message=\"Your opponent is staggered, but recoveres quickly and continues the fight.\"\n  return [critical_outcome,message]\n", ["random"]], "testi": [".py", "from dataclasses import dataclass\n\nimport random\nimport combatfunctions as cf\n\n@dataclass\nclass Opponent:\n name:str=\"dummy\"\n WS:int=70\n S:int=4\n T:int=3\n W:int=7\n I:int=40\n A:int=2\n parry:str=\"on\"\n \n def calculate_initiatives(self):\n \n  initiatives=[]\n  i=0\n  while i <self.A:\n   initiatives.append(int(self.I /self.A *(self.A -i)))\n   i +=1\n   \n  return initiatives\n  \n  \n  \n  \ndef ThrowHit():\n\n a=random.randint(1,100)\n print(f\"You threw {a}\")\n \n b=taistelija.WS\n \n \n \n if b >=a:\n  return a\n else :\n  return 100\n  \ndef FindHitLocation(hit:int):\n\n hitlocations=[15,35,55,80,90,100]\n hitlocationnames=[\"Head\",\"Right Arm\",\"Left Arm\",\"Body\",\"Left Leg\",\"Right Leg\"]\n \n temp=str(hit)\n \n if len(temp)==2:\n  hitlocation=int(temp[1]+temp[0])\n else :\n  hitlocation=int(temp+\"0\")\n  \n i=0\n \n while True :\n \n  if hitlocation <=hitlocations[i]:\n   return hitlocationnames[i]\n  else :\n   i +=1\n   \ndef ThrowDamage(s):\n a=random.randint(1,6)\n \n damagetotal=a+s\n \n return damagetotal\n \n \ndef FindHitOutcome(damage,toughness):\n\n if damage >toughness:\n  return damage -toughness\n else :\n  return 0\n  \ndef findHitOrder(hitorder_current,initiative_list,name):\n hitorder_temp=[]\n if len(hitorder_current)==0:\n  hitorder_temp=initiative_list\n else :\n  i=0\n  hitorder_temp=hitorder_current\n  hitorder_temp.append(0)\n  \n  while i <len(initiative_list):\n   h=0\n   \n   while initiative_list[i]<hitorder_temp[h]:\n   \n    h +=1\n    \n   hitorder_temp.insert(h,initiative_list[i])\n   \n   i +=1\n   \n if hitorder_temp[len(hitorder_temp)-1]==0:\n  hitorder_temp.pop()\n  \n return hitorder_temp\n \ndef createHitList(hitlist_current,initiative_list,name):\n\n i=0\n \n while i <len(initiative_list):\n \n  hitlist_current.append([initiative_list[i],name,0,name[0]])\n  \n  i +=1\n  \n return hitlist_current\n \ndef combatRound(hitlist):\n\n i=0\n \n all_attacks=len(hitlist)\n \n hitlist[2][2]=1\n hitlist[4][2]=1\n \n while i <all_attacks:\n \n  if hitlist[i][3]==\"a\":\n  \n   if hitlist[i][2]==0:\n    print(f\"{attacker.name} hits on initiative {hitlist[i][0]}\")\n   else :\n    print(f\"{attacker.name} has already used his attack on initiative {hitlist[i][0]}\")\n   i +=1\n  else :\n   if hitlist[i][2]==0:\n    print(f\"{defender.name} hits on initiative {hitlist[i][0]}\")\n   else :\n    print(f\"{defender.name} has already used his attack on initiative {hitlist[i][0]}\")\n   i +=1\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n return \"hy\u00f6kk\u00e4ykset tehty\"\n \nattacker_stats=[(\"Kultisti\",50,5,6,9,50,2),(\"Kaaosmutantti\",45,4,7,10,60,3)]\nattackers=[\"a1\",\"a2\"]\nhitlist=[]\n\nall_attacks=0\n\ndefender=Opponent(name=\"Sankari\",S=5,T=4,I=70,A=4,W=10)\n\nattacker=Opponent(name=\"Kultisti\",I=80,A=3,T=3,W=10)\n\nt1_initiatives=cf.calculateInitiatives(defender.I,defender.A)\n\n\n\n\n\ni=0\nwhile i <len(attackers):\n temp_initiative=cf.calculateInitiatives(attacker_stats[i][5],attacker_stats[i][6])\n \n hitlist=createHitList(hitlist,temp_initiative,attackers[i])\n i +=1\n \nhitlist=createHitList(hitlist,t1_initiatives,\"d\")\n\nhitlist.sort(reverse=True )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprint(cf.checkSuddenDeath(2,60))\n\n\n\n\n", ["combatfunctions", "dataclasses", "random"]], "repo.combat": [".py", "from browser import document,bind\nfrom browser.html import P,BR,B\nfrom dataclasses import dataclass\n\nimport random\nimport combatfunctions as cf\n\n@dataclass\nclass Opponent:\n name:str=\"dummy\"\n WS:int=80\n S:int=4\n T:int=3\n W:int=7\n I:int=40\n A:int=2\n \n def throwDamage(self):\n  a=random.randint(1,6)\n  \n  if a ==6:\n   return self.extraDamage()\n  else :\n   return a+self.S\n   \n def extraDamage(self):\n  damage=6\n  \n  if random.randint(1,100)<self.WS:\n  \n   docOutput(\"Extra damage!\",\"bold\")\n   roll=random.randint(1,6)\n   while roll ==6:\n    docOutput(\"More extra damage\",\"bold\")\n    damage +=6\n    roll=random.randint(1,6)\n    \n   damage +=roll\n   \n  return damage+self.S\n  \n  \n  \n  \n  \n  \n@bind(document[\"set_attributes\"],\"click\")\ndef setAttributes(ev):\n\n setAttributesOf(attacker,\"a\")\n setAttributesOf(defender,\"d\")\n \n docOutput(\"Attributes set\")\n \n \ndef docOutput(string,styling=None ):\n\n if styling ==\"bold\":\n  document[\"output\"]<=B(string)\n  document[\"output\"]<=BR()\n else :\n  document[\"output\"]<=(string)\n  document[\"output\"]<=BR()\n  \n  \ndef setAttributesOf(opponent,suffix):\n opponent.name=document['n_'+suffix].value\n opponent.WS=int(document['ws_'+suffix].value)\n opponent.S=int(document['s_'+suffix].value)\n opponent.T=int(document['t_'+suffix].value)\n opponent.W=int(document['w_'+suffix].value)\n opponent.I=int(document['i_'+suffix].value)\n opponent.A=int(document['a_'+suffix].value)\n \ndef runCombatRound(att_inits,def_inits,attacks):\n i=0\n ai=0\n di=0\n \n message=\"\"\n \n while i <attacks:\n \n  if att_inits[ai]>def_inits[di]:\n  \n   message=attacker.name+\" hits on initative \"+str(att_inits[ai])\n   docOutput(message)\n   \n   ai +=1\n   \n   hit=random.randint(1,100)\n   \n   message=attacker.name+\" threw \"+str(hit)\n   docOutput(message)\n   \n   if hit <=attacker.WS:\n   \n    message=attacker.name+\" hits \"+str(cf.findHitLocation(hit))\n    docOutput(message)\n    damage=attacker.throwDamage()\n    \n    outcome=cf.findHitOutcome(damage,defender.T)\n    \n    message=attacker.name+\" did \"+str(damage)+\" points damage and \"+defender.name+\" lost \"+str(outcome)+\" wounds\"\n    docOutput(message)\n    defender.W -=outcome\n    \n    if defender.W <0:\n     return defender.name+\" has \"+str(defender.W)+\" wounds.Throw a critical!\"\n    else :\n     message=defender.name+\" has \"+str(defender.W)+\" wounds left.\"\n     docOutput(message)\n     \n   else :\n   \n    if cf.checkFumble(hit)==\"Miss!\":\n     docOutput(\"Miss!\")\n    else :\n     message=attacker.name+\" fumbled with roll \"+str(hit)+\". Loose one attack.\"\n     docOutput(message,\"bold\")\n     if ai <len(att_inits)-1:\n      ai +=1\n      attacks -=1\n  else :\n   message=defender.name+\" hits on initative \"+str(def_inits[di])\n   docOutput(message)\n   \n   di +=1\n   \n   hit=random.randint(1,100)\n   \n   message=defender.name+\" threw \"+str(hit)\n   docOutput(message)\n   \n   if hit <=defender.WS:\n   \n    message=defender.name+\" hits \"+str(cf.findHitLocation(hit))\n    docOutput(message)\n    damage=defender.throwDamage()\n    \n    outcome=cf.findHitOutcome(damage,attacker.T)\n    \n    message=defender.name+\" did \"+str(damage)+\" points damage and \"+attacker.name+\" lost \"+str(outcome)+\" wounds\"\n    docOutput(message)\n    attacker.W -=outcome\n    \n    if attacker.W <0:\n     return attacker.name+\" has \"+str(attacker.W)+\" wounds.Throw a critical!\"\n    else :\n     message=attacker.name+\" has \"+str(attacker.W)+\" wounds left.\"\n     docOutput(message)\n     \n   else :\n   \n    if cf.checkFumble(hit)==\"Miss!\":\n     docOutput(\"Miss!\")\n    else :\n     message=defender.name+\" fumbled with roll \"+str(hit)+\". Loose one attack.\"\n     docOutput(message)\n     if di <len(def_inits)-1:\n      di +=1\n      attacks -=1\n      \n  i +=1\n  \n return \"Attacks done\"\n \n@bind(document[\"round\"],\"click\")\ndef round(ev):\n\n defender_initiatives=cf.calculateInitiatives(defender.I,defender.A)\n attacker_initiatives=cf.calculateInitiatives(attacker.I,attacker.A)\n \n i=0\n all_attacks=attacker.A+defender.A\n \n \n \n defender_initiatives.append(0)\n attacker_initiatives.append(0)\n \n document[\"output\"]<=P(B(runCombatRound(attacker_initiatives,defender_initiatives,all_attacks)))\n \n \n document[\"output\"].scrollTop=document[\"output\"].scrollHeight\n \n \n \n \ndefender=Opponent()\n\nattacker=Opponent()\n\n\n\n", ["browser", "browser.html", "combatfunctions", "dataclasses", "random"]], "repo.combatfunctions": [".py", "\n\nimport random\n\ndef calculateInitiatives(init:int,a:int):\n\n initiatives=[]\n i=0\n while i <a:\n  initiatives.append(int(init /a *(a -i)))\n  i +=1\n  \n return initiatives\n \ndef throwHit(ws:int):\n\n a=random.randint(1,100)\n \n result=[]\n \n if ws >=a:\n  result=[\"Hit!\",str(a)]\n  return result\n else :\n  result=[checkFumble(a),str(a)]\n  return result\n  \ndef findHitLocation(hit:int):\n\n hitlocations=[15,35,55,80,90,100]\n hitlocationnames=[\"Head\",\"Right Arm\",\"Left Arm\",\"Body\",\"Left Leg\",\"Right Leg\"]\n \n temp=str(hit)\n \n if len(temp)==2:\n  hitlocation=int(temp[1]+temp[0])\n else :\n  hitlocation=int(temp+\"0\")\n  \n i=0\n \n while True :\n \n  if hitlocation <=hitlocations[i]:\n   return hitlocationnames[i]\n  else :\n   i +=1\n   \ndef findHitOutcome(damage,defence):\n if damage >defence:\n  return damage -defence\n else :\n  return 0\n  \ndef checkFumble(hit:int):\n\n temp=str(hit)\n \n if len(temp)==1:\n  return \"Miss!\"\n  \n if hit ==100:\n  return \"Fumble!\"\n  \n if temp[0]==temp[1]:\n  return \"Fumble!\"\n  \n return \"Miss!\"\n", ["random"]], "temp.pygit": [".py", "''\n\n\n\n\n\n\nimport argparse,collections,difflib,enum,hashlib,operator,os,stat\nimport struct,sys,time,urllib.request,zlib\n\n\n\nIndexEntry=collections.namedtuple('IndexEntry',[\n'ctime_s','ctime_n','mtime_s','mtime_n','dev','ino','mode','uid',\n'gid','size','sha1','flags','path',\n])\n\n\nclass ObjectType(enum.Enum):\n ''\n\n \n commit=1\n tree=2\n blob=3\n \n \ndef read_file(path):\n ''\n with open(path,'rb')as f:\n  return f.read()\n  \n  \ndef write_file(path,data):\n ''\n with open(path,'wb')as f:\n  f.write(data)\n  \n  \ndef init(repo):\n ''\n os.mkdir(repo)\n os.mkdir(os.path.join(repo,'.git'))\n for name in ['objects','refs','refs/heads']:\n  os.mkdir(os.path.join(repo,'.git',name))\n write_file(os.path.join(repo,'.git','HEAD'),b'ref: refs/heads/master')\n print('initialized empty repository: {}'.format(repo))\n \n \ndef hash_object(data,obj_type,write=True ):\n ''\n\n \n header='{} {}'.format(obj_type,len(data)).encode()\n full_data=header+b'\\x00'+data\n sha1=hashlib.sha1(full_data).hexdigest()\n if write:\n  path=os.path.join('.git','objects',sha1[:2],sha1[2:])\n  if not os.path.exists(path):\n   os.makedirs(os.path.dirname(path),exist_ok=True )\n   write_file(path,zlib.compress(full_data))\n return sha1\n \n \ndef find_object(sha1_prefix):\n ''\n\n\n \n if len(sha1_prefix)<2:\n  raise ValueError('hash prefix must be 2 or more characters')\n obj_dir=os.path.join('.git','objects',sha1_prefix[:2])\n rest=sha1_prefix[2:]\n objects=[name for name in os.listdir(obj_dir)if name.startswith(rest)]\n if not objects:\n  raise ValueError('object {!r} not found'.format(sha1_prefix))\n if len(objects)>=2:\n  raise ValueError('multiple objects ({}) with prefix {!r}'.format(\n  len(objects),sha1_prefix))\n return os.path.join(obj_dir,objects[0])\n \n \ndef read_object(sha1_prefix):\n ''\n\n \n path=find_object(sha1_prefix)\n full_data=zlib.decompress(read_file(path))\n nul_index=full_data.index(b'\\x00')\n header=full_data[:nul_index]\n obj_type,size_str=header.decode().split()\n size=int(size_str)\n data=full_data[nul_index+1:]\n assert size ==len(data),'expected size {}, got {} bytes'.format(\n size,len(data))\n return (obj_type,data)\n \n \ndef cat_file(mode,sha1_prefix):\n ''\n\n\n\n\n \n obj_type,data=read_object(sha1_prefix)\n if mode in ['commit','tree','blob']:\n  if obj_type !=mode:\n   raise ValueError('expected object type {}, got {}'.format(\n   mode,obj_type))\n  sys.stdout.buffer.write(data)\n elif mode =='size':\n  print(len(data))\n elif mode =='type':\n  print(obj_type)\n elif mode =='pretty':\n  if obj_type in ['commit','blob']:\n   sys.stdout.buffer.write(data)\n  elif obj_type =='tree':\n   for mode,path,sha1 in read_tree(data=data):\n    type_str='tree'if stat.S_ISDIR(mode)else 'blob'\n    print('{:06o} {} {}\\t{}'.format(mode,type_str,sha1,path))\n  else :\n   assert False ,'unhandled object type {!r}'.format(obj_type)\n else :\n  raise ValueError('unexpected mode {!r}'.format(mode))\n  \n  \ndef read_index():\n ''\n try :\n  data=read_file(os.path.join('.git','index'))\n except FileNotFoundError:\n  return []\n digest=hashlib.sha1(data[:-20]).digest()\n assert digest ==data[-20:],'invalid index checksum'\n signature,version,num_entries=struct.unpack('!4sLL',data[:12])\n assert signature ==b'DIRC',\\\n 'invalid index signature {}'.format(signature)\n assert version ==2,'unknown index version {}'.format(version)\n entry_data=data[12:-20]\n entries=[]\n i=0\n while i+62 <len(entry_data):\n  fields_end=i+62\n  fields=struct.unpack('!LLLLLLLLLL20sH',entry_data[i:fields_end])\n  path_end=entry_data.index(b'\\x00',fields_end)\n  path=entry_data[fields_end:path_end]\n  entry=IndexEntry(*(fields+(path.decode(),)))\n  entries.append(entry)\n  entry_len=((62+len(path)+8)//8)*8\n  i +=entry_len\n assert len(entries)==num_entries\n return entries\n \n \ndef ls_files(details=False ):\n ''\n\n \n for entry in read_index():\n  if details:\n   stage=(entry.flags >>12)&3\n   print('{:6o} {} {:}\\t{}'.format(\n   entry.mode,entry.sha1.hex(),stage,entry.path))\n  else :\n   print(entry.path)\n   \n   \ndef get_status():\n ''\n\n \n paths=set()\n for root,dirs,files in os.walk('.'):\n  dirs[:]=[d for d in dirs if d !='.git']\n  for file in files:\n   path=os.path.join(root,file)\n   path=path.replace('\\\\','/')\n   if path.startswith('./'):\n    path=path[2:]\n   paths.add(path)\n entries_by_path={e.path:e for e in read_index()}\n entry_paths=set(entries_by_path)\n changed={p for p in (paths&entry_paths)\n if hash_object(read_file(p),'blob',write=False )!=\n entries_by_path[p].sha1.hex()}\n new=paths -entry_paths\n deleted=entry_paths -paths\n return (sorted(changed),sorted(new),sorted(deleted))\n \n \ndef status():\n ''\n changed,new,deleted=get_status()\n if changed:\n  print('changed files:')\n  for path in changed:\n   print('   ',path)\n if new:\n  print('new files:')\n  for path in new:\n   print('   ',path)\n if deleted:\n  print('deleted files:')\n  for path in deleted:\n   print('   ',path)\n   \n   \ndef diff():\n ''\n changed,_,_=get_status()\n entries_by_path={e.path:e for e in read_index()}\n for i,path in enumerate(changed):\n  sha1=entries_by_path[path].sha1.hex()\n  obj_type,data=read_object(sha1)\n  assert obj_type =='blob'\n  index_lines=data.decode().splitlines()\n  working_lines=read_file(path).decode().splitlines()\n  diff_lines=difflib.unified_diff(\n  index_lines,working_lines,\n  '{} (index)'.format(path),\n  '{} (working copy)'.format(path),\n  lineterm='')\n  for line in diff_lines:\n   print(line)\n  if i <len(changed)-1:\n   print('-'*70)\n   \n   \ndef write_index(entries):\n ''\n packed_entries=[]\n for entry in entries:\n  entry_head=struct.pack('!LLLLLLLLLL20sH',\n  entry.ctime_s,entry.ctime_n,entry.mtime_s,entry.mtime_n,\n  entry.dev,entry.ino,entry.mode,entry.uid,entry.gid,\n  entry.size,entry.sha1,entry.flags)\n  path=entry.path.encode()\n  length=((62+len(path)+8)//8)*8\n  packed_entry=entry_head+path+b'\\x00'*(length -62 -len(path))\n  packed_entries.append(packed_entry)\n header=struct.pack('!4sLL',b'DIRC',2,len(entries))\n all_data=header+b''.join(packed_entries)\n digest=hashlib.sha1(all_data).digest()\n write_file(os.path.join('.git','index'),all_data+digest)\n \n \ndef add(paths):\n ''\n paths=[p.replace('\\\\','/')for p in paths]\n all_entries=read_index()\n entries=[e for e in all_entries if e.path not in paths]\n for path in paths:\n  sha1=hash_object(read_file(path),'blob')\n  st=os.stat(path)\n  flags=len(path.encode())\n  assert flags <(1 <<12)\n  entry=IndexEntry(\n  int(st.st_ctime),0,int(st.st_mtime),0,st.st_dev,\n  st.st_ino,st.st_mode,st.st_uid,st.st_gid,st.st_size,\n  bytes.fromhex(sha1),flags,path)\n  entries.append(entry)\n entries.sort(key=operator.attrgetter('path'))\n write_index(entries)\n \n \ndef write_tree():\n ''\n tree_entries=[]\n for entry in read_index():\n  assert '/'not in entry.path,\\\n  'currently only supports a single, top-level directory'\n  mode_path='{:o} {}'.format(entry.mode,entry.path).encode()\n  tree_entry=mode_path+b'\\x00'+entry.sha1\n  tree_entries.append(tree_entry)\n return hash_object(b''.join(tree_entries),'tree')\n \n \ndef get_local_master_hash():\n ''\n master_path=os.path.join('.git','refs','heads','master')\n try :\n  return read_file(master_path).decode().strip()\n except FileNotFoundError:\n  return None\n  \n  \ndef commit(message,author=None ):\n ''\n\n \n tree=write_tree()\n parent=get_local_master_hash()\n if author is None :\n  author='{} <{}>'.format(\n  os.environ['GIT_AUTHOR_NAME'],os.environ['GIT_AUTHOR_EMAIL'])\n timestamp=int(time.mktime(time.localtime()))\n utc_offset=-time.timezone\n author_time='{} {}{:02}{:02}'.format(\n timestamp,\n '+'if utc_offset >0 else '-',\n abs(utc_offset)//3600,\n (abs(utc_offset)//60)%60)\n lines=['tree '+tree]\n if parent:\n  lines.append('parent '+parent)\n lines.append('author {} {}'.format(author,author_time))\n lines.append('committer {} {}'.format(author,author_time))\n lines.append('')\n lines.append(message)\n lines.append('')\n data='\\n'.join(lines).encode()\n sha1=hash_object(data,'commit')\n master_path=os.path.join('.git','refs','heads','master')\n write_file(master_path,(sha1+'\\n').encode())\n print('committed to master: {:7}'.format(sha1))\n return sha1\n \n \ndef extract_lines(data):\n ''\n lines=[]\n i=0\n for _ in range(1000):\n  line_length=int(data[i:i+4],16)\n  line=data[i+4:i+line_length]\n  lines.append(line)\n  if line_length ==0:\n   i +=4\n  else :\n   i +=line_length\n  if i >=len(data):\n   break\n return lines\n \n \ndef build_lines_data(lines):\n ''\n result=[]\n for line in lines:\n  result.append('{:04x}'.format(len(line)+5).encode())\n  result.append(line)\n  result.append(b'\\n')\n result.append(b'0000')\n return b''.join(result)\n \n \ndef http_request(url,username,password,data=None ):\n ''\n\n \n password_manager=urllib.request.HTTPPasswordMgrWithDefaultRealm()\n password_manager.add_password(None ,url,username,password)\n auth_handler=urllib.request.HTTPBasicAuthHandler(password_manager)\n opener=urllib.request.build_opener(auth_handler)\n f=opener.open(url,data=data)\n return f.read()\n \n \ndef get_remote_master_hash(git_url,username,password):\n ''\n\n \n url=git_url+'/info/refs?service=git-receive-pack'\n response=http_request(url,username,password)\n lines=extract_lines(response)\n assert lines[0]==b'# service=git-receive-pack\\n'\n assert lines[1]==b''\n if lines[2][:40]==b'0'*40:\n  return None\n master_sha1,master_ref=lines[2].split(b'\\x00')[0].split()\n assert master_ref ==b'refs/heads/master'\n assert len(master_sha1)==40\n return master_sha1.decode()\n \n \ndef read_tree(sha1=None ,data=None ):\n ''\n\n \n if sha1 is not None :\n  obj_type,data=read_object(sha1)\n  assert obj_type =='tree'\n elif data is None :\n  raise TypeError('must specify \"sha1\" or \"data\"')\n i=0\n entries=[]\n for _ in range(1000):\n  end=data.find(b'\\x00',i)\n  if end ==-1:\n   break\n  mode_str,path=data[i:end].decode().split()\n  mode=int(mode_str,8)\n  digest=data[end+1:end+21]\n  entries.append((mode,path,digest.hex()))\n  i=end+1+20\n return entries\n \n \ndef find_tree_objects(tree_sha1):\n ''\n\n \n objects={tree_sha1}\n for mode,path,sha1 in read_tree(sha1=tree_sha1):\n  if stat.S_ISDIR(mode):\n   objects.update(find_tree_objects(sha1))\n  else :\n   objects.add(sha1)\n return objects\n \n \ndef find_commit_objects(commit_sha1):\n ''\n\n \n objects={commit_sha1}\n obj_type,commit=read_object(commit_sha1)\n assert obj_type =='commit'\n lines=commit.decode().splitlines()\n tree=next(l[5:45]for l in lines if l.startswith('tree '))\n objects.update(find_tree_objects(tree))\n parents=(l[7:47]for l in lines if l.startswith('parent '))\n for parent in parents:\n  objects.update(find_commit_objects(parent))\n return objects\n \n \ndef find_missing_objects(local_sha1,remote_sha1):\n ''\n\n \n local_objects=find_commit_objects(local_sha1)\n if remote_sha1 is None :\n  return local_objects\n remote_objects=find_commit_objects(remote_sha1)\n return local_objects -remote_objects\n \n \ndef encode_pack_object(obj):\n ''\n\n \n obj_type,data=read_object(obj)\n type_num=ObjectType[obj_type].value\n size=len(data)\n byte=(type_num <<4)|(size&0x0f)\n size >>=4\n header=[]\n while size:\n  header.append(byte |0x80)\n  byte=size&0x7f\n  size >>=7\n header.append(byte)\n return bytes(header)+zlib.compress(data)\n \n \ndef create_pack(objects):\n ''\n\n \n header=struct.pack('!4sLL',b'PACK',2,len(objects))\n body=b''.join(encode_pack_object(o)for o in sorted(objects))\n contents=header+body\n sha1=hashlib.sha1(contents).digest()\n data=contents+sha1\n return data\n \n \ndef push(git_url,username=None ,password=None ):\n ''\n if username is None :\n  username=os.environ['GIT_USERNAME']\n if password is None :\n  password=os.environ['GIT_PASSWORD']\n remote_sha1=get_remote_master_hash(git_url,username,password)\n local_sha1=get_local_master_hash()\n missing=find_missing_objects(local_sha1,remote_sha1)\n print('updating remote master from {} to {} ({} object{})'.format(\n remote_sha1 or 'no commits',local_sha1,len(missing),\n ''if len(missing)==1 else 's'))\n lines=['{} {} refs/heads/master\\x00 report-status'.format(\n remote_sha1 or ('0'*40),local_sha1).encode()]\n data=build_lines_data(lines)+create_pack(missing)\n url=git_url+'/git-receive-pack'\n response=http_request(url,username,password,data=data)\n lines=extract_lines(response)\n assert len(lines)>=2,\\\n 'expected at least 2 lines, got {}'.format(len(lines))\n assert lines[0]==b'unpack ok\\n',\\\n \"expected line 1 b'unpack ok', got: {}\".format(lines[0])\n assert lines[1]==b'ok refs/heads/master\\n',\\\n \"expected line 2 b'ok refs/heads/master\\n', got: {}\".format(lines[1])\n return (remote_sha1,missing)\n \n \nif __name__ =='__main__':\n parser=argparse.ArgumentParser()\n sub_parsers=parser.add_subparsers(dest='command',metavar='command')\n sub_parsers.required=True\n \n sub_parser=sub_parsers.add_parser('add',\n help='add file(s) to index')\n sub_parser.add_argument('paths',nargs='+',metavar='path',\n help='path(s) of files to add')\n \n sub_parser=sub_parsers.add_parser('cat-file',\n help='display contents of object')\n valid_modes=['commit','tree','blob','size','type','pretty']\n sub_parser.add_argument('mode',choices=valid_modes,\n help='object type (commit, tree, blob) or display mode (size, '\n 'type, pretty)')\n sub_parser.add_argument('hash_prefix',\n help='SHA-1 hash (or hash prefix) of object to display')\n \n sub_parser=sub_parsers.add_parser('commit',\n help='commit current state of index to master branch')\n sub_parser.add_argument('-a','--author',\n help='commit author in format \"A U Thor <author@example.com>\" '\n '(uses GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL environment '\n 'variables by default)')\n sub_parser.add_argument('-m','--message',required=True ,\n help='text of commit message')\n \n sub_parser=sub_parsers.add_parser('diff',\n help='show diff of files changed (between index and working '\n 'copy)')\n \n sub_parser=sub_parsers.add_parser('hash-object',\n help='hash contents of given path (and optionally write to '\n 'object store)')\n sub_parser.add_argument('path',\n help='path of file to hash')\n sub_parser.add_argument('-t',choices=['commit','tree','blob'],\n default='blob',dest='type',\n help='type of object (default %(default)r)')\n sub_parser.add_argument('-w',action='store_true',dest='write',\n help='write object to object store (as well as printing hash)')\n \n sub_parser=sub_parsers.add_parser('init',\n help='initialize a new repo')\n sub_parser.add_argument('repo',\n help='directory name for new repo')\n \n sub_parser=sub_parsers.add_parser('ls-files',\n help='list files in index')\n sub_parser.add_argument('-s','--stage',action='store_true',\n help='show object details (mode, hash, and stage number) in '\n 'addition to path')\n \n sub_parser=sub_parsers.add_parser('push',\n help='push master branch to given git server URL')\n sub_parser.add_argument('git_url',\n help='URL of git repo, eg: https://github.com/benhoyt/pygit.git')\n sub_parser.add_argument('-p','--password',\n help='password to use for authentication (uses GIT_PASSWORD '\n 'environment variable by default)')\n sub_parser.add_argument('-u','--username',\n help='username to use for authentication (uses GIT_USERNAME '\n 'environment variable by default)')\n \n sub_parser=sub_parsers.add_parser('status',\n help='show status of working copy')\n \n args=parser.parse_args()\n if args.command =='add':\n  add(args.paths)\n elif args.command =='cat-file':\n  try :\n   cat_file(args.mode,args.hash_prefix)\n  except ValueError as error:\n   print(error,file=sys.stderr)\n   sys.exit(1)\n elif args.command =='commit':\n  commit(args.message,author=args.author)\n elif args.command =='diff':\n  diff()\n elif args.command =='hash-object':\n  sha1=hash_object(read_file(args.path),args.type,write=args.write)\n  print(sha1)\n elif args.command =='init':\n  init(args.repo)\n elif args.command =='ls-files':\n  ls_files(details=args.stage)\n elif args.command =='push':\n  push(args.git_url,username=args.username,password=args.password)\n elif args.command =='status':\n  status()\n else :\n  assert False ,'unexpected command {!r}'.format(args.command)\n", ["argparse", "collections", "difflib", "enum", "hashlib", "operator", "os", "stat", "struct", "sys", "time", "urllib.request", "zlib"]]}
__BRYTHON__.update_VFS(scripts)
